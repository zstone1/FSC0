module CoinProblem
import Data.Vect
import FoldTheorems

record CurrencyConstraints (d : Vect k Nat) where
  constructor ValidateCurrency
  hasOne : Elem 1 d

Currency : {k:Nat} -> Type
Currency {k}= (d : Vect k Nat ** CurrencyConstraints {k=k} d) 

MkCurrency : (d : Vect k Nat) -> {auto q : Elem 1 d} -> Currency {k=k}
MkCurrency d {q} = (d ** ValidateCurrency q)

getDenoms : Currency {k=k} -> Vect k Nat
getDenoms x = fst x

getConstraints : (cur : Currency {k=k}) -> CurrencyConstraints (getDenoms cur)
getConstraints cur = ?getConstraints_rhs

record CoinConstraints (n:Nat) (cur:Currency {k=k}) where
  constructor ValidateCoin
  isDenom : Elem n (getDenoms cur) 

Coin : Currency -> Type
Coin cur = (n : Nat ** CoinConstraints n cur)

getVal : Coin d -> Nat
getVal = fst

MkCoin : (n:Nat) -> (cur : Currency) -> {auto q : Elem n (getDenoms cur)} -> Coin cur
MkCoin {q} n cur = (n ** ValidateCoin q)

cSum : Vect n (Coin d) -> Nat
cSum coins = sum (map getVal coins) 

|||Proof that cSum distributes like sum.
CSumDistr : (as : Vect n (Coin d)) -> (bs : Vect m (Coin d)) -> cSum as + cSum bs = cSum (as ++ bs)
CSumDistr as bs = 
    let as' = map getVal as in
    let bs' = map getVal bs in
    let asbs' = map getVal (as ++ bs) in 
    let l1 : (sum as' + sum bs' = sum (as' ++ bs')) = SumAssociates as' bs' in
    let p2 : (as' ++ bs' = asbs') = MapAppendDistributes getVal as bs in
    let l4 : (sum as' + sum bs' = sum (asbs')) = rewrite sym p2 in l1 in
        l4

record ChangeConstraints (cur : Currency{k=k}) (amt :Nat) (a: Vect n (Coin cur)) where
  constructor ValidateChange
  amtCheck : amt = cSum a

data Change : (cur : Currency) -> (amt: Nat) -> Type where
  MkChange : (n:Nat) -> (a : Vect n (Coin cur)) -> ChangeConstraints cur amt a -> Change cur amt

|||Given change for n and change for m, I can combine and make change for n+m
MergeChange : (c1 : Change cur n) -> (c2 : Change cur m) -> Change cur (n + m)
MergeChange (MkChange {amt = amt1} _ a1 const1) (MkChange {amt = amt2} _ a2 const2) = 
  let (amt1Check, amt2Check) = (amtCheck const1, amtCheck const2) in
  let sumCheckA : (amt1 + amt2 = cSum a1 + cSum a2) = 
    rewrite amt1Check in
    rewrite amt2Check in Refl in
  let sumCheckB : (amt1 + amt2 = cSum (a1 ++ a2)) = rewrite sym $ CSumDistr a1 a2 in sumCheckA in
    MkChange _ (a1 ++ a2) (ValidateChange sumCheckB) 

GiveChange : (cur : Currency) -> (amt: Nat) -> Change cur amt
GiveChange _ Z = MkChange Z [] (ValidateChange Refl)
GiveChange cur (S k) with (isElem (S k) (getDenoms cur))
  | Yes prf = let c = MkCoin (S k) cur in 
              let p1 : (plus (S k) 0 = cSum [c]) = Refl in
              let p2 : ((S k) = cSum [c]) = (rewrite sym $ plusZeroRightNeutral (S k) in p1) in 
                MkChange 1 [c] (ValidateChange p2)
  | No contr = --let c = MkCoin 1 cur in
                   ?foo
--
-- 

--CSumDist : (as:Vect n (Coin d)) -> (bs : Vect m (Coin d)) ->
--              (CSum as) + (CSum bs) = CSum ( as ++ bs)
--CSumDist [] bs = Refl
--CSumDist (a :: as) bs = 
--  let p1 = CSumDist [a] as in 
--  let p2 = CSumDist as bs in
--  let p3 = CSumDist [a] (as++bs)in
--  let q1 = cong{f = \e => e+CSum bs} p1 in
--  let l1 = plusAssociative (CSum [a]) (CSum as) (CSum bs) in 
--  let q2 = rewrite l1 in q1 in
--  let q3:(CSum [a] + CSum(as ++ bs) = CSum (a::as) + CSum bs) = rewrite p2 in q1 in  
--    ?a_12
