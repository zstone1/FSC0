module MinimumExt
import PreorderReasoningExt
import Data.So
import MaybeExt
import Projective
import VectExt
import Decidable.Order  
%access export 

public export
minimum : (TotalPreorder t po) => t -> t -> t
minimum {po} x y with (porder {po} x y)
    | Left _ = x
    | Right _ = y

minimumLemma1 : Ordered t po => (f . Prelude.Basics.fst) (minimum @{pj} {po=ProjLifted (Pair u) po} (a, f a) (b, f b)) = minimum @{inht} {po} (f a) (f b)
minimumLemma1 {u} {f} {a} {b} {po} with (porder {po=ProjLifted (Pair u) po} (a, f a) (b, f b))
  | (Left (LiftToProj po p1)) with (porder {po} (f a) (f b))
    |Left p2 = Refl
    |Right p2= antisymmetric (f a) (f b) p1 p2
  | (Right (LiftToProj po p1)) with (porder {po} (f a) (f b))
    |Left p2 = antisymmetric (f b) (f a) p1 p2
    |Right p2 = Refl

public export
minElem : TotalPreorder t po => Vect (S k) t -> t
minElem (x :: []) = x
minElem {po} (x :: x'::xs)  = minimum {po} x (minElem {po} (x'::xs)) 

minElemLemma1 : TotalPreorder t po => (x:t) -> (xs : Vect k t) -> (po (minElem {po} (x::xs)) x)
minElemLemma1 x [] = reflexive x
minElemLemma1 {po} x (y :: xs) with (porder {po} x (minElem {po} (y::xs))) 
  |Left p = reflexive x
  |Right p2 = p2


minElemLemma2 : TotalPreorder t po =>  (x:t) -> (xs: Vect (S k) t) -> po (minElem {po}(x::xs)) (minElem {po} xs)
minElemLemma2 {po} {k=Z} x (x' :: []) with (porder {po} x x') 
  |Left p = p
  |Right p = reflexive x'
minElemLemma2 {po} {k=S j} x (x' :: xs) with (porder {po} x (minElem {po} (x'::xs)))
  |Left p = p 
  |Right p = reflexive (minElem {po} (x'::xs))
